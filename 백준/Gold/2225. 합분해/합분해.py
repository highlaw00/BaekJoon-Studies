n, k = map(int, input().split())

# dp 테이블 갱신
dp = [1 for _ in range(n+1)]

# dp[i] = k개의 수를 사용할 때, i라는 숫자를 만들 수 있는 경우의 수
# dp[i] = sum(dp[i-0], dp[i-1], ..., dp[i-i])
# 왜?
# dp[i-0]은(갱신되기 이전이기에) k-1개의 수를 사용할 때 i라는 수를 만드는 경우의 수 이기 때문에
# i라는 숫자를 만들 때, 0 + (i-0) 과 같은 꼴로 더해 i를 만들 수 있다.
# 또, i-1라는 숫자를 만들 때, 1 + (i-1) 과 같은 꼴로 더해 i를 만들 수 있다.
# 이런식으로 모든 경우를 다 갱신하면 된다

# dp의 값을 모두 1로 초기화 한 이유. K가 1일 때, 각 숫자를 만들 수 있는 경우의 수는 1이기 때문
# k를 1부터 k까지 증가시키며 점진적으로 값을 찾아나간다
for t in range(1, k):
    dp_c = dp[:]
    # i => 1 ~ n
    # i가 0일 때는 무조건 1개의 경우만 가능
    for i in range(1, n+1):
        temp = 0
        for j in range(i+1):
            temp += dp_c[i-j]
        dp[i] = temp

print(dp[n] % 1_000_000_000)
